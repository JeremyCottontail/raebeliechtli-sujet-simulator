<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Räbeliechtli Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; width: 100vw; height: 100vh; }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }

    .btn {
      padding: 8px 16px;
      border: 2px solid #444;
      background: rgba(0, 0, 0, 0.75);
      color: #ccc;
      font-family: sans-serif;
      font-size: 14px;
      cursor: pointer;
      border-radius: 4px;
      transition: border-color 0.15s, background 0.15s, color 0.15s;
      user-select: none;
      min-width: 130px;
      text-align: left;
    }
    .btn.active {
      border-color: #c060ff;
      background: rgba(100, 20, 160, 0.5);
      color: #fff;
    }
    .btn:hover:not(.active) {
      border-color: #888;
      color: #fff;
    }

    #brush-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.6);
    }
    #brush-group label {
      color: #999;
      font-size: 12px;
      font-family: sans-serif;
    }
    #brushSize {
      width: 100%;
      accent-color: #c060ff;
      cursor: pointer;
    }

    #intensity-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.6);
    }
    #intensity-group label {
      color: #999;
      font-size: 12px;
      font-family: sans-serif;
    }
    #candleIntensity {
      width: 100%;
      accent-color: #c060ff;
      cursor: pointer;
    }

    #grid-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.6);
    }
    #grid-group > label {
      color: #999;
      font-size: 12px;
      font-family: sans-serif;
    }
    .grid-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .grid-row span {
      color: #888;
      font-size: 11px;
      font-family: sans-serif;
    }
    .grid-row input[type="number"] {
      width: 48px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid #444;
      border-radius: 3px;
      color: #ddd;
      font-size: 12px;
      font-family: monospace;
      padding: 2px 6px;
      text-align: right;
    }
    .grid-row input[type="number"]:focus {
      outline: none;
      border-color: #c060ff;
    }
    #btn-grid {
      padding: 5px 10px;
      background: rgba(100, 20, 160, 0.35);
      border: 1px solid #7030c0;
      border-radius: 3px;
      color: #c090ff;
      font-family: sans-serif;
      font-size: 12px;
      cursor: pointer;
      text-align: center;
      transition: background 0.15s, color 0.15s;
    }
    #btn-grid:hover {
      background: rgba(120, 40, 180, 0.55);
      color: #fff;
    }

    #canvas-size-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.6);
    }
    #canvas-size-group > label {
      color: #999;
      font-size: 12px;
      font-family: sans-serif;
    }
    #canvasW, #canvasH {
      width: 100%;
      accent-color: #c060ff;
      cursor: pointer;
    }

    #templates-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 4px;
      background: rgba(0, 0, 0, 0.6);
    }
    #templates-group > label {
      color: #999;
      font-size: 12px;
      font-family: sans-serif;
    }
    #template-btns {
      display: flex;
      gap: 4px;
    }
    .template-btn {
      flex: 1;
      padding: 5px 4px;
      background: rgba(100, 20, 160, 0.35);
      border: 1px solid #7030c0;
      border-radius: 3px;
      color: #c090ff;
      font-family: sans-serif;
      font-size: 11px;
      cursor: pointer;
      text-align: center;
      transition: background 0.15s, color 0.15s;
    }
    .template-btn:hover {
      background: rgba(120, 40, 180, 0.55);
      color: #fff;
    }

    #turnip-count {
      color: #666;
      font-size: 11px;
      font-family: monospace;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
    }

    #info {
      position: fixed;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      color: #444;
      font-family: sans-serif;
      font-size: 11px;
      pointer-events: none;
      white-space: nowrap;
    }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <button class="btn active" id="btn-rotate">Rotate</button>
    <button class="btn"        id="btn-paint" >Paint Black</button>
    <button class="btn"        id="btn-place" >Place/Remove Turnip</button>
    <button class="btn"        id="btn-clear"         >Clear Canvas/Painting</button>
    <button class="btn"        id="btn-clear-turnips" >Clear Turnips</button>
    <button class="btn"        id="btn-clear-all"     >Clear All</button>
    <div id="brush-group">
      <label>Brush Size: <span id="brushVal">20</span> px</label>
      <input type="range" id="brushSize" min="4" max="150" value="20" />
    </div>
    <div id="intensity-group">
      <label>Candle Intensity: <span id="intensityVal">100</span>%</label>
      <input type="range" id="candleIntensity" min="0" max="100" value="100" />
    </div>
    <div id="canvas-size-group">
      <label>Canvas Size</label>
      <div class="grid-row">
        <span>Width</span>
        <span id="canvasWVal">2.5 m</span>
      </div>
      <input type="range" id="canvasW" min="0.5" max="6" step="0.1" value="2.5" />
      <div class="grid-row">
        <span>Height</span>
        <span id="canvasHVal">4.0 m</span>
      </div>
      <input type="range" id="canvasH" min="0.5" max="8" step="0.1" value="4" />
    </div>
    <div id="grid-group">
      <label>Grid Generator</label>
      <div class="grid-row">
        <span>Columns</span>
        <input type="number" id="gridCols" min="1" max="30" value="3" />
      </div>
      <div class="grid-row">
        <span>Rows</span>
        <input type="number" id="gridRows" min="1" max="30" value="3" />
      </div>
      <button id="btn-grid">Place Grid</button>
    </div>
    <div id="templates-group">
      <label>Templates</label>
      <div id="template-btns">
        <button class="template-btn" id="tpl-cat">Cat</button>
        <button class="template-btn" id="tpl-tiger">Tiger</button>
        <button class="template-btn" id="tpl-spongebob">Spongebob</button>
      </div>
    </div>
    <div id="turnip-count">Turnips: 0 / 900</div>
  </div>
  <div id="info">Rotate: drag · Paint: click+drag on canvas · Place: click on canvas</div>

  <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// ─── Constants ────────────────────────────────────────────────────────────────
let CANVAS_W       = 2.5;   // metres (mutable — canvas size sliders update these)
let CANVAS_H       = 4;     // metres
const MAX_TURNIPS  = 900;
const PAINT_W      = 1280;  // px — matches 2.5:4 aspect ratio
const PAINT_H      = 2048;  // px
const TURNIP_SCALE = 0.28;  // uniform scale applied to every turnip group

// ─── GLSL Shaders ─────────────────────────────────────────────────────────────

const CANVAS_VERT = /* glsl */`
  varying vec2 vUv;
  varying vec3 vWorldPos;

  void main() {
    vUv = uv;
    vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const CANVAS_FRAG = /* glsl */`
  precision highp float;

  #define MAX_TURNIPS 900

  uniform sampler2D uPaintTex;
  uniform sampler2D uTurnipData;  // MAX_TURNIPS×1 RGBA float tex: pos.xyz, intensity
  uniform int   uNumTurnips;
  uniform float uConeHalfAngle;

  // Warm candle yellow — not orange, not white
  const vec3 CANDLE_COLOR = vec3(1.0, 0.82, 0.38);

  varying vec2 vUv;
  varying vec3 vWorldPos;

  float coneContrib(vec3 lightPos, vec3 fragPos, float halfAngle) {
    vec3 toFrag = fragPos - lightPos;
    float dist  = length(toFrag);
    if (dist < 0.001) return 0.0;

    vec3 toFragN = toFrag / dist;

    // Cone axis points straight up (+Y)
    float cosTheta = dot(vec3(0.0, 1.0, 0.0), toFragN);
    float cosEdge  = cos(halfAngle);
    if (cosTheta < cosEdge) return 0.0;

    float cosInner = cos(halfAngle * 0.5);
    float edge = smoothstep(cosEdge, cosInner, cosTheta);

    // Tight falloff — full brightness at the opening, fades to ~0 within 3× turnip height (~0.45m)
    float range = 0.45;
    float att = pow(max(1.0 - dist / range, 0.0), 2.0);

    return edge * att;
  }

  void main() {
    vec4 paint = texture2D(uPaintTex, vUv);

    // Dim ambient so canvas is just barely visible in the dark scene.
    // Black paint stays near-black; white paint becomes off-white in ambient.
    vec3 color = paint.rgb * 0.12;

    for (int i = 0; i < MAX_TURNIPS; i++) {
      if (i >= uNumTurnips) break;
      vec4 td = texture2D(uTurnipData, vec2((float(i) + 0.5) / float(MAX_TURNIPS), 0.5));
      float contrib = coneContrib(td.rgb, vWorldPos, uConeHalfAngle);
      color += max(paint.rgb, vec3(0.1)) * CANDLE_COLOR * contrib * td.a * 3.0;
    }

    gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
  }
`;

// ─── State ────────────────────────────────────────────────────────────────────
const state = {
  mode: 'rotate',
  brushSize: 20,
  isPointerDown: false,
  lastUV: null,
  turnips: [],
  candleIntensity: 1.0,
};

// ─── Renderer ─────────────────────────────────────────────────────────────────
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

// ─── Scene & camera ───────────────────────────────────────────────────────────
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  50,
  window.innerWidth / window.innerHeight,
  0.01,
  300
);
camera.position.set(0, 2, 5);

// ─── Orbit Controls ───────────────────────────────────────────────────────────
const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0, 2, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.minDistance = 0.5;
controls.maxDistance = 20;
controls.update();

// ─── Post-processing ──────────────────────────────────────────────────────────
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(Math.floor(window.innerWidth * 0.5), Math.floor(window.innerHeight * 0.5)),
  0.6,   // strength — subtle, not overwhelming
  0.4,   // radius
  1.20   // threshold — only the bright flame blooms, turnip body stays clean
);
composer.addPass(bloomPass);
composer.addPass(new OutputPass());

// ─── Ambient lighting ─────────────────────────────────────────────────────────
scene.add(new THREE.AmbientLight(0x110022, 0.4));
scene.add(new THREE.HemisphereLight(0x220033, 0x000000, 0.2));

// ─── Paint Texture ────────────────────────────────────────────────────────────
const paintCanvas = document.createElement('canvas');
paintCanvas.width  = PAINT_W;
paintCanvas.height = PAINT_H;
const paintCtx = paintCanvas.getContext('2d');
paintCtx.fillStyle = '#ffffff';
paintCtx.fillRect(0, 0, PAINT_W, PAINT_H);

const paintTexture = new THREE.CanvasTexture(paintCanvas);
paintTexture.colorSpace = THREE.SRGBColorSpace;
paintTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

function paintAt(u, v, brushPx, prevUV) {
  const x = u * PAINT_W;
  const y = (1 - v) * PAINT_H;
  paintCtx.fillStyle = 'rgba(0,0,0,0.9)';
  if (prevUV) {
    const px0 = prevUV.u * PAINT_W;
    const py0 = (1 - prevUV.v) * PAINT_H;
    const dx = x - px0, dy = y - py0;
    const steps = Math.max(1, Math.ceil(Math.hypot(dx, dy) / (brushPx * 0.25)));
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      paintCtx.beginPath();
      paintCtx.arc(px0 + dx * t, py0 + dy * t, brushPx * 0.5, 0, Math.PI * 2);
      paintCtx.fill();
    }
  } else {
    paintCtx.beginPath();
    paintCtx.arc(x, y, brushPx * 0.5, 0, Math.PI * 2);
    paintCtx.fill();
  }
  paintTexture.needsUpdate = true;
}

function clearPaintCanvas() {
  paintCtx.fillStyle = '#ffffff';
  paintCtx.fillRect(0, 0, PAINT_W, PAINT_H);
  paintTexture.needsUpdate = true;
}

// ─── Canvas Plane (backdrop) ──────────────────────────────────────────────────
// RGBA float texture: R=pos.x, G=pos.y, B=pos.z, A=flicker intensity
// Using a texture instead of uniform arrays avoids WebGL uniform-count limits.
const turnipData    = new Float32Array(MAX_TURNIPS * 4);
const turnipDataTex = new THREE.DataTexture(
  turnipData, MAX_TURNIPS, 1, THREE.RGBAFormat, THREE.FloatType
);
turnipDataTex.minFilter      = THREE.NearestFilter;
turnipDataTex.magFilter      = THREE.NearestFilter;
turnipDataTex.generateMipmaps = false;
turnipDataTex.flipY           = false;
turnipDataTex.needsUpdate     = true;

const canvasMat = new THREE.ShaderMaterial({
  vertexShader:   CANVAS_VERT,
  fragmentShader: CANVAS_FRAG,
  uniforms: {
    uPaintTex:      { value: paintTexture },
    uNumTurnips:    { value: 0 },
    uTurnipData:    { value: turnipDataTex },
    uConeHalfAngle: { value: 0.52 },
  },
  side: THREE.FrontSide,
});

const canvasGeo  = new THREE.PlaneGeometry(CANVAS_W, CANVAS_H, 1, 1);
const canvasMesh = new THREE.Mesh(canvasGeo, canvasMat);
canvasMesh.position.set(0, CANVAS_H / 2, 0);
scene.add(canvasMesh);

// Border lines around the canvas
const border = new THREE.LineSegments(
  new THREE.EdgesGeometry(canvasGeo),
  new THREE.LineBasicMaterial({ color: 0x333333 })
);
border.position.copy(canvasMesh.position);
border.position.z = 0.002;
scene.add(border);

// ─── Canvas resize ────────────────────────────────────────────────────────────
function resizeCanvas(w, h) {
  CANVAS_W = w;
  CANVAS_H = h;

  const newGeo = new THREE.PlaneGeometry(w, h, 1, 1);

  canvasMesh.geometry.dispose();
  canvasMesh.geometry = newGeo;
  canvasMesh.position.set(0, h / 2, 0);

  border.geometry.dispose();
  border.geometry = new THREE.EdgesGeometry(newGeo);
  border.position.copy(canvasMesh.position);
  border.position.z = 0.002;
}

// ─── Floor ────────────────────────────────────────────────────────────────────
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(12, 10),
  new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// ─── Turnip geometry (shared) ─────────────────────────────────────────────────
function getTurnipOuterProfile() {
  // Nearly spherical turnip — max girth at 55% height, symmetric curves.
  // Large opening (outer rim 0.140) so interior & flame are clearly visible.
  return [
    new THREE.Vector2(0.000, 0.000),  // pointed tip
    new THREE.Vector2(0.055, 0.055),  // starts widening fast
    new THREE.Vector2(0.140, 0.140),  // lower quadrant — near-circular arc
    new THREE.Vector2(0.210, 0.250),  // belly
    new THREE.Vector2(0.230, 0.320),  // maximum girth
    new THREE.Vector2(0.220, 0.390),  // upper belly — mirrors lower
    new THREE.Vector2(0.185, 0.445),  // shoulder, smooth
    new THREE.Vector2(0.145, 0.490),  // short neck
    new THREE.Vector2(0.140, 0.500),  // wide top opening
  ];
}

function getTurnipInnerProfile() {
  // Hollow cavity — ~18mm wall thickness throughout.
  return [
    new THREE.Vector2(0.000, 0.210),  // flat cavity bottom
    new THREE.Vector2(0.070, 0.265),
    new THREE.Vector2(0.140, 0.355),
    new THREE.Vector2(0.165, 0.420),
    new THREE.Vector2(0.148, 0.462),
    new THREE.Vector2(0.118, 0.490),
    new THREE.Vector2(0.112, 0.500),  // inner rim edge
  ];
}

const OUTER_GEO  = new THREE.LatheGeometry(getTurnipOuterProfile(), 40);
const INNER_GEO  = new THREE.LatheGeometry(getTurnipInnerProfile(), 40);
const RIM_GEO    = new THREE.RingGeometry(0.112, 0.140, 40);  // wide carved-wall rim
const CANDLE_GEO = new THREE.CylinderGeometry(0.008, 0.008, 0.12, 8);
const FLAME_GEO  = new THREE.SphereGeometry(0.014, 8, 8);

// ─── Shared turnip materials (created ONCE, reused across all turnips) ────────
const SHARED_MATS = {
  outer: new THREE.MeshStandardMaterial({
    color: 0xf0eaff, emissive: new THREE.Color(0x220044),
    emissiveIntensity: 0.5, roughness: 0.75, side: THREE.DoubleSide,
  }),
  inner: new THREE.MeshStandardMaterial({
    color: 0xffe0c0, emissive: new THREE.Color(0xff7700),
    emissiveIntensity: 1.2, roughness: 0.9, side: THREE.BackSide,
  }),
  rim: new THREE.MeshStandardMaterial({
    color: 0xeee8ff, emissive: new THREE.Color(0x330055),
    emissiveIntensity: 0.4, roughness: 0.7, side: THREE.DoubleSide,
  }),
  candle: new THREE.MeshStandardMaterial({
    color: 0xfff8e8, emissive: new THREE.Color(0xffddaa), emissiveIntensity: 1.0,
  }),
  flame: new THREE.MeshStandardMaterial({
    color: 0xffff99, emissive: new THREE.Color(0xffcc44),
    emissiveIntensity: 9, transparent: true, opacity: 0.92,
  }),
};

// Materials moved to SHARED_MATS above — no per-turnip allocation.

// ─── SpotLight pool (8 max Three.js lights) ───────────────────────────────────
const SPOT_POOL_SIZE = 0;
const spotPool = [];
for (let i = 0; i < SPOT_POOL_SIZE; i++) {
  const sl = new THREE.SpotLight(0xffcc66, 0, 4.0, Math.PI / 6, 0.5, 2);
  sl.visible = false;
  sl.castShadow = false;
  scene.add(sl);
  scene.add(sl.target);
  spotPool.push(sl);
}

function assignSpotLights() {
  const n = state.turnips.length;
  for (let p = 0; p < SPOT_POOL_SIZE; p++) {
    const sl = spotPool[p];
    const ti = n - 1 - p;
    if (ti < 0) {
      sl.visible = false;
      sl.intensity = 0;
    } else {
      const t = state.turnips[ti];
      sl.visible = true;
      sl.position.copy(t.lightPos);
      sl.target.position.set(t.lightPos.x, t.lightPos.y + 4, 0.0);
      sl.target.updateMatrixWorld();
      sl.intensity = t.baseIntensity;
    }
  }
}

// ─── Turnip instance ──────────────────────────────────────────────────────────
function createTurnipInstance(worldPos) {
  const TS = TURNIP_SCALE;

  const rimMesh = new THREE.Mesh(RIM_GEO, SHARED_MATS.rim);
  rimMesh.rotation.x = -Math.PI / 2;
  rimMesh.position.y = 0.500;

  const candleMesh = new THREE.Mesh(CANDLE_GEO, SHARED_MATS.candle);
  candleMesh.position.y = 0.295;

  const flameMesh = new THREE.Mesh(FLAME_GEO, SHARED_MATS.flame);
  flameMesh.position.y = 0.380;  // visible above inner cavity bottom, below wide opening

  const group = new THREE.Group();
  group.add(
    new THREE.Mesh(OUTER_GEO, SHARED_MATS.outer),
    new THREE.Mesh(INNER_GEO, SHARED_MATS.inner),
    rimMesh, candleMesh, flameMesh
  );

  // Scale the whole group — all children scale uniformly
  group.scale.setScalar(TS);

  group.position.copy(worldPos);
  group.position.z += 0.230 * TS;  // push forward by scaled max radius
  // Keep turnip within canvas bounds (account for scaled half-width)
  const hw = 0.230 * TS;
  const hh = 0.500 * TS;
  group.position.y = Math.max(hh, Math.min(CANVAS_H - hh * 0.1, group.position.y));
  group.position.x = Math.max(-CANVAS_W / 2 + hw, Math.min(CANVAS_W / 2 - hw, group.position.x));

  scene.add(group);

  // No per-turnip PointLight — kills performance at 20+ turnips.
  // The SpotLight pool handles 3D scene illumination; emissive materials
  // give the warm inner glow; the canvas shader handles backdrop lighting.

  // lightPos sits at the BASE of the turnip (in world Y), at the canvas surface (z=0).
  // This means the cone has already spread to ~2× the opening radius by the time
  // it reaches the turnip top — no sharp point, immediate width at exit.
  const lightPos = new THREE.Vector3(
    group.position.x,
    group.position.y,         // base of turnip in world space
    0.0                       // at canvas surface
  );

  return {
    group, flameMesh, lightPos,
    flickerPhase: [Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2],
    flickerSpeed: [1.8 + Math.random() * 1.2, 4.5 + Math.random() * 2.0, 0.4 + Math.random() * 0.6],
    baseIntensity: 2.5 + Math.random() * 1.0,
  };
}

// ─── Flicker ──────────────────────────────────────────────────────────────────
function computeFlicker(time, phase, speed) {
  const raw = Math.sin(time * speed[0] * Math.PI * 2 + phase[0]) * 0.50
            + Math.sin(time * speed[1] * Math.PI * 2 + phase[1]) * 0.30
            + Math.sin(time * speed[2] * Math.PI * 2 + phase[2]) * 0.20;
  return Math.max(0.30, Math.min(1.0, 0.55 + (raw + 1.0) * 0.225));
}

function updateFlicker(time) {
  const n = state.turnips.length;
  for (let i = 0; i < n; i++) {
    const t = state.turnips[i];
    const f = computeFlicker(time, t.flickerPhase, t.flickerSpeed);
    t.flameMesh.position.y = 0.380 + (Math.random() - 0.5) * 0.008;
    t.flameMesh.position.x = (Math.random() - 0.5) * 0.006;
    turnipData[i * 4 + 3] = f * state.candleIntensity;
  }
  turnipDataTex.needsUpdate = true;
  canvasMat.uniforms.uNumTurnips.value = n;

  const m = Math.min(n, SPOT_POOL_SIZE);
  for (let p = 0; p < m; p++) {
    const ti = n - 1 - p;
    spotPool[p].intensity = state.turnips[ti].baseIntensity * 0.5 * turnipData[ti * 4 + 3];
  }
}

// ─── Uniform sync ─────────────────────────────────────────────────────────────
function syncTurnipPositions() {
  const n = state.turnips.length;
  for (let i = 0; i < n; i++) {
    const pos = state.turnips[i].lightPos;
    turnipData[i * 4]     = pos.x;
    turnipData[i * 4 + 1] = pos.y;
    turnipData[i * 4 + 2] = pos.z;
    // turnipData[i*4+3] (intensity) is written every frame by updateFlicker
  }
  turnipDataTex.needsUpdate = true;
  canvasMat.uniforms.uNumTurnips.value = n;
}

// ─── Raycasting ───────────────────────────────────────────────────────────────
const raycaster = new THREE.Raycaster();
const mouseNDC  = new THREE.Vector2();

function raycastCanvas(event) {
  mouseNDC.x =  (event.clientX / window.innerWidth)  * 2 - 1;
  mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouseNDC, camera);
  const hits = raycaster.intersectObject(canvasMesh, false);
  return hits.length > 0 ? hits[0] : null;
}

function raycastTurnip(event) {
  mouseNDC.x =  (event.clientX / window.innerWidth)  * 2 - 1;
  mouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouseNDC, camera);
  const groups = state.turnips.map(t => t.group);
  const hits = raycaster.intersectObjects(groups, true);  // recursive into children
  if (hits.length === 0) return null;
  const hitGroup = hits[0].object.parent;
  return state.turnips.find(t => t.group === hitGroup) ?? null;
}

function removeTurnip(turnip) {
  scene.remove(turnip.group);
  state.turnips.splice(state.turnips.indexOf(turnip), 1);
  syncTurnipPositions();
  assignSpotLights();
  document.getElementById('turnip-count').textContent =
    `Turnips: ${state.turnips.length} / ${MAX_TURNIPS}`;
}

function placeTurnip(event) {
  if (state.turnips.length >= MAX_TURNIPS) return;
  const hit = raycastCanvas(event);
  if (!hit) return;
  state.turnips.push(createTurnipInstance(hit.point));
  syncTurnipPositions();
  assignSpotLights();
  document.getElementById('turnip-count').textContent =
    `Turnips: ${state.turnips.length} / ${MAX_TURNIPS}`;
}

// ─── UI & Interaction ─────────────────────────────────────────────────────────
const modeButtons = {
  rotate: document.getElementById('btn-rotate'),
  paint:  document.getElementById('btn-paint'),
  place:  document.getElementById('btn-place'),
};

function setMode(mode) {
  state.mode = mode;
  controls.enabled = (mode === 'rotate');
  for (const [m, btn] of Object.entries(modeButtons)) {
    btn.classList.toggle('active', m === mode);
  }
  renderer.domElement.style.cursor = { rotate: 'grab', paint: 'crosshair', place: 'cell' }[mode];
}

modeButtons.rotate.addEventListener('click', () => setMode('rotate'));
modeButtons.paint.addEventListener ('click', () => setMode('paint'));
modeButtons.place.addEventListener ('click', () => setMode('place'));
function clearTurnips() {
  for (const t of state.turnips) scene.remove(t.group);
  state.turnips.length = 0;
  syncTurnipPositions();
  assignSpotLights();
  document.getElementById('turnip-count').textContent = `Turnips: 0 / ${MAX_TURNIPS}`;
}

document.getElementById('btn-clear'        ).addEventListener('click', clearPaintCanvas);
document.getElementById('btn-clear-turnips').addEventListener('click', clearTurnips);
document.getElementById('btn-clear-all'    ).addEventListener('click', () => { clearTurnips(); clearPaintCanvas(); });

const brushSizeEl = document.getElementById('brushSize');
const brushValEl  = document.getElementById('brushVal');
brushSizeEl.addEventListener('input', () => {
  state.brushSize = parseInt(brushSizeEl.value, 10);
  brushValEl.textContent = state.brushSize;
});

function placeGrid(cols, rows) {
  const hw   = 0.230 * TURNIP_SCALE;
  const hh   = 0.500 * TURNIP_SCALE;
  const xMin = -CANVAS_W / 2 + hw;
  const xMax =  CANVAS_W / 2 - hw;
  const yMin = hh;
  const yMax = CANVAS_H - hh * 0.1;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (state.turnips.length >= MAX_TURNIPS) break;
      const x = cols === 1 ? 0 : xMin + (xMax - xMin) * (c / (cols - 1));
      const y = rows === 1 ? (yMin + yMax) / 2 : yMin + (yMax - yMin) * (r / (rows - 1));
      state.turnips.push(createTurnipInstance(new THREE.Vector3(x, y, 0)));
    }
  }
  syncTurnipPositions();
  assignSpotLights();
  document.getElementById('turnip-count').textContent =
    `Turnips: ${state.turnips.length} / ${MAX_TURNIPS}`;
}

document.getElementById('btn-grid').addEventListener('click', () => {
  const cols = Math.max(1, Math.min(30, parseInt(document.getElementById('gridCols').value, 10) || 1));
  const rows = Math.max(1, Math.min(30, parseInt(document.getElementById('gridRows').value, 10) || 1));
  placeGrid(cols, rows);
});

const candleIntensityEl = document.getElementById('candleIntensity');
const intensityValEl    = document.getElementById('intensityVal');
candleIntensityEl.addEventListener('input', () => {
  state.candleIntensity = parseInt(candleIntensityEl.value, 10) / 100;
  intensityValEl.textContent = candleIntensityEl.value;
  SHARED_MATS.flame.emissiveIntensity = 9   * state.candleIntensity;
  SHARED_MATS.inner.emissiveIntensity = 1.2 * state.candleIntensity;
});

const canvasWEl    = document.getElementById('canvasW');
const canvasHEl    = document.getElementById('canvasH');
const canvasWValEl = document.getElementById('canvasWVal');
const canvasHValEl = document.getElementById('canvasHVal');
function onCanvasSizeInput() {
  const w = parseFloat(canvasWEl.value);
  const h = parseFloat(canvasHEl.value);
  canvasWValEl.textContent = w.toFixed(1) + ' m';
  canvasHValEl.textContent = h.toFixed(1) + ' m';
  resizeCanvas(w, h);
}
canvasWEl.addEventListener('input', onCanvasSizeInput);
canvasHEl.addEventListener('input', onCanvasSizeInput);

renderer.domElement.addEventListener('pointerdown', (e) => {
  state.isPointerDown = true;
  state.lastUV = null;
  if (state.mode === 'paint') {
    const hit = raycastCanvas(e);
    if (hit && hit.uv) {
      paintAt(hit.uv.x, hit.uv.y, state.brushSize, null);
      state.lastUV = { u: hit.uv.x, v: hit.uv.y };
    }
  } else if (state.mode === 'place') {
    const hit = raycastTurnip(e);
    if (hit) removeTurnip(hit);
    else placeTurnip(e);
  }
});

renderer.domElement.addEventListener('pointermove', (e) => {
  if (!state.isPointerDown || state.mode !== 'paint') return;
  const hit = raycastCanvas(e);
  if (!hit || !hit.uv) return;
  paintAt(hit.uv.x, hit.uv.y, state.brushSize, state.lastUV);
  state.lastUV = { u: hit.uv.x, v: hit.uv.y };
});

renderer.domElement.addEventListener('pointerup',    () => { state.isPointerDown = false; state.lastUV = null; });
renderer.domElement.addEventListener('pointerleave', () => { state.isPointerDown = false; state.lastUV = null; });

// ─── Template drawings ────────────────────────────────────────────────────────
function drawCat(ctx, w, h) {
  // Peeking cat — large black silhouette rising from the bottom of the canvas,
  // round eyes with iris + highlight, thin whiskers to canvas edges.
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, w, h);

  const cx  = w * 0.5;
  const hr  = w * 0.40;    // head radius — fills most of the canvas width
  const hcy = h * 0.80;    // head centre; bottom of head extends just off-canvas

  ctx.fillStyle = '#000000';

  // Left ear (triangle with slight tilt)
  ctx.beginPath();
  ctx.moveTo(cx - hr * 0.46, hcy - hr * 0.84);  // inner base
  ctx.lineTo(cx - hr * 0.80, hcy - hr * 1.34);  // tip
  ctx.lineTo(cx - hr * 0.73, hcy - hr * 0.72);  // outer base
  ctx.closePath();
  ctx.fill();

  // Right ear
  ctx.beginPath();
  ctx.moveTo(cx + hr * 0.46, hcy - hr * 0.84);
  ctx.lineTo(cx + hr * 0.80, hcy - hr * 1.34);
  ctx.lineTo(cx + hr * 0.73, hcy - hr * 0.72);
  ctx.closePath();
  ctx.fill();

  // Head (large filled circle)
  ctx.beginPath();
  ctx.arc(cx, hcy, hr, 0, Math.PI * 2);
  ctx.fill();

  // Eyes: white sclera → black iris → white highlight dot
  const eyeX = hr * 0.42;
  const eyeY = hcy - hr * 0.24;
  const eyeR = hr * 0.285;
  const irisR = eyeR * 0.68;
  const hlR   = eyeR * 0.22;

  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(cx - eyeX, eyeY, eyeR, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + eyeX, eyeY, eyeR, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = '#000000';
  ctx.beginPath(); ctx.arc(cx - eyeX, eyeY, irisR, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + eyeX, eyeY, irisR, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(cx - eyeX + irisR * 0.30, eyeY - irisR * 0.36, hlR, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + eyeX + irisR * 0.30, eyeY - irisR * 0.36, hlR, 0, Math.PI * 2); ctx.fill();

  // Whiskers — drawn from face centre to canvas edges; the segments buried inside
  // the black head silhouette are invisible (black-on-black), only the tips that
  // emerge beyond the circle show as thin black lines on white background.
  ctx.strokeStyle = '#000000';
  ctx.lineWidth   = w * 0.005;
  ctx.lineCap     = 'round';
  const wy = hcy + hr * 0.06;
  ctx.beginPath(); ctx.moveTo(cx, wy - hr * 0.04); ctx.lineTo(0, wy - hr * 0.14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, wy + hr * 0.05); ctx.lineTo(0, wy + hr * 0.10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, wy - hr * 0.04); ctx.lineTo(w, wy - hr * 0.14); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, wy + hr * 0.05); ctx.lineTo(w, wy + hr * 0.10); ctx.stroke();
}

function drawTiger(ctx, w, h) {
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, w, h);
  ctx.fillStyle = '#000000';

  const cx = w*.5, cy = h*.30, hr = w*.32;

  // Round ears + wide head + body
  ctx.beginPath(); ctx.arc(cx-hr*.72, cy-hr*.82, hr*.26, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx+hr*.72, cy-hr*.82, hr*.26, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx, cy, hr, hr*.90, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx, cy+hr*1.58, hr*.78, hr*1.05, 0, 0, Math.PI*2); ctx.fill();

  // White body stripes
  ctx.strokeStyle = '#ffffff'; ctx.lineWidth = w*.032; ctx.lineCap = 'round';
  for (const xo of [-0.52,-0.22,0.08,0.38,0.68]) {
    ctx.beginPath(); ctx.moveTo(cx+xo*hr, cy+hr*.65);
    ctx.quadraticCurveTo(cx+(xo+.05)*hr, cy+hr*1.58, cx+xo*hr, cy+hr*2.52); ctx.stroke();
  }

  // White face areas
  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(cx-hr*.72, cy-hr*.82, hr*.14, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx+hr*.72, cy-hr*.82, hr*.14, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx-hr*.40, cy-hr*.12, hr*.21, hr*.19, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx+hr*.40, cy-hr*.12, hr*.21, hr*.19, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx, cy+hr*.35, hr*.44, hr*.28, 0, 0, Math.PI*2); ctx.fill();

  // Black face details
  ctx.fillStyle = '#000000';
  ctx.beginPath(); ctx.ellipse(cx-hr*.40, cy-hr*.12, hr*.07, hr*.15, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cx+hr*.40, cy-hr*.12, hr*.07, hr*.15, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx, cy+hr*.18); ctx.lineTo(cx-hr*.12, cy+hr*.35); ctx.lineTo(cx+hr*.12, cy+hr*.35); ctx.closePath(); ctx.fill();

  // Forehead stripes
  ctx.strokeStyle = '#000000'; ctx.lineWidth = w*.022; ctx.lineCap = 'round';
  for (const xo of [-0.38,0,0.38]) {
    ctx.beginPath(); ctx.moveTo(cx+xo*hr, cy-hr*.75);
    ctx.quadraticCurveTo(cx+xo*hr*.7, cy-hr*.45, cx+xo*hr*.4, cy-hr*.30); ctx.stroke();
  }

  // Mouth + whiskers
  ctx.lineWidth = w*.018;
  ctx.beginPath(); ctx.moveTo(cx, cy+hr*.35); ctx.quadraticCurveTo(cx-hr*.22, cy+hr*.54, cx-hr*.44, cy+hr*.44); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy+hr*.35); ctx.quadraticCurveTo(cx+hr*.22, cy+hr*.54, cx+hr*.44, cy+hr*.44); ctx.stroke();
  ctx.lineWidth = w*.012;
  for (const dy of [.30,.40,.48]) {
    ctx.beginPath(); ctx.moveTo(cx-hr*.12, cy+dy*hr); ctx.lineTo(cx-hr*.92, cy+dy*hr); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx+hr*.12, cy+dy*hr); ctx.lineTo(cx+hr*.92, cy+dy*hr); ctx.stroke();
  }
}

function drawSpongebob(ctx, w, h) {
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, w, h);
  ctx.fillStyle = '#000000';

  const cx = w*.5;
  const bw = w*.54, bh = h*.52, bx = cx-bw*.5, by = h*.16;
  const pantsY = by + bh*.65;

  // Body
  ctx.beginPath(); ctx.roundRect(bx, by, bw, bh, bw*.06); ctx.fill();

  // Sponge holes (white)
  ctx.fillStyle = '#ffffff';
  for (const [rx,ry,rr] of [
    [.18,.10,.055],[.55,.07,.042],[.82,.16,.060],
    [.10,.28,.044],[.38,.24,.070],[.72,.26,.050],
    [.88,.34,.042],[.24,.40,.052],[.60,.38,.062],
    [.12,.52,.060],[.45,.55,.040],[.80,.50,.052],
  ]) {
    const hy = by + ry*(bh*.62);
    if (hy < pantsY-4) { ctx.beginPath(); ctx.arc(bx+rx*bw, hy, rr*bw, 0, Math.PI*2); ctx.fill(); }
  }

  // Belt (white line + black buckle)
  ctx.fillStyle = '#ffffff'; ctx.fillRect(bx, pantsY-2, bw, h*.018);
  ctx.fillStyle = '#000000'; ctx.fillRect(cx-bw*.08, pantsY-4, bw*.16, h*.035);

  // Eyes
  const eyeR = bw*.155, eyeY = by+bh*.21;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.arc(cx-bw*.22, eyeY, eyeR, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx+bw*.22, eyeY, eyeR, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#000000'; ctx.lineWidth = w*.016;
  ctx.beginPath(); ctx.arc(cx-bw*.22, eyeY, eyeR, 0, Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.arc(cx+bw*.22, eyeY, eyeR, 0, Math.PI*2); ctx.stroke();

  // Pupils
  ctx.fillStyle = '#000000';
  ctx.beginPath(); ctx.arc(cx-bw*.22+eyeR*.30, eyeY+eyeR*.20, eyeR*.50, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx+bw*.22-eyeR*.30, eyeY+eyeR*.20, eyeR*.50, 0, Math.PI*2); ctx.fill();

  // Eyelashes
  ctx.lineWidth = w*.013; ctx.lineCap = 'round';
  for (const side of [-1,1]) {
    const ex = cx + side*bw*.22;
    for (const ang of [-0.4,0,0.4]) {
      ctx.beginPath();
      ctx.moveTo(ex+Math.sin(ang)*eyeR, eyeY-eyeR*.90);
      ctx.lineTo(ex+Math.sin(ang)*eyeR*1.5, eyeY-eyeR*1.45); ctx.stroke();
    }
  }

  // Nose
  ctx.fillStyle = '#000000';
  ctx.beginPath(); ctx.ellipse(cx, by+bh*.41, bw*.04, bw*.06, 0, 0, Math.PI*2); ctx.fill();

  // Mouth (white teeth half-ellipse)
  const mouthY = by+bh*.52;
  ctx.fillStyle = '#ffffff';
  ctx.beginPath(); ctx.ellipse(cx, mouthY+h*.018, bw*.28, h*.052, 0, 0, Math.PI); ctx.fill();
  ctx.strokeStyle = '#000000'; ctx.lineWidth = w*.016;
  ctx.beginPath(); ctx.ellipse(cx, mouthY+h*.018, bw*.28, h*.052, 0, 0, Math.PI); ctx.stroke();
  ctx.lineWidth = w*.014;
  for (let i = 1; i < 4; i++) {
    const tx = (cx-bw*.28) + (bw*.56*i/4);
    ctx.beginPath(); ctx.moveTo(tx, mouthY+h*.002); ctx.lineTo(tx, mouthY+h*.044); ctx.stroke();
  }

  // Tie
  const tieTopY = mouthY+h*.068;
  ctx.fillStyle = '#000000';
  ctx.beginPath(); ctx.arc(cx, tieTopY, bw*.050, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.moveTo(cx-bw*.065, tieTopY+h*.008); ctx.lineTo(cx+bw*.065, tieTopY+h*.008); ctx.lineTo(cx, pantsY-h*.008); ctx.closePath(); ctx.fill();

  // Freckles
  for (const side of [-1,1]) {
    for (let i = 0; i < 3; i++) {
      ctx.beginPath(); ctx.arc(cx+side*(bw*.30+i*bw*.09), eyeY+eyeR*1.25, w*.010, 0, Math.PI*2); ctx.fill();
    }
  }
}

function applyTemplate(drawFn) {
  clearTurnips();
  clearPaintCanvas();
  drawFn(paintCtx, PAINT_W, PAINT_H);
  paintTexture.needsUpdate = true;

  const GRID = 15;
  const hw   = 0.230 * TURNIP_SCALE, hh = 0.500 * TURNIP_SCALE;
  const xMin = -CANVAS_W / 2 + hw, xMax = CANVAS_W / 2 - hw;
  const yMin = hh, yMax = CANVAS_H - hh * 0.1;
  const imageData = paintCtx.getImageData(0, 0, PAINT_W, PAINT_H);

  for (let r = 0; r < GRID && state.turnips.length < MAX_TURNIPS; r++) {
    for (let c = 0; c < GRID && state.turnips.length < MAX_TURNIPS; c++) {
      const x = xMin + (xMax - xMin) * (c / (GRID - 1));
      const y = yMin + (yMax - yMin) * (r / (GRID - 1));
      const px  = Math.max(0, Math.min(PAINT_W - 1, Math.floor((x + CANVAS_W / 2) / CANVAS_W * PAINT_W)));
      const py  = Math.max(0, Math.min(PAINT_H - 1, Math.floor((1 - y / CANVAS_H) * PAINT_H)));
      const idx = (py * PAINT_W + px) * 4;
      if (imageData.data[idx] + imageData.data[idx+1] + imageData.data[idx+2] > 600) {
        state.turnips.push(createTurnipInstance(new THREE.Vector3(x, y, 0)));
      }
    }
  }
  syncTurnipPositions();
  assignSpotLights();
  document.getElementById('turnip-count').textContent =
    `Turnips: ${state.turnips.length} / ${MAX_TURNIPS}`;
}

document.getElementById('tpl-cat'      ).addEventListener('click', () => applyTemplate(drawCat));
document.getElementById('tpl-tiger'    ).addEventListener('click', () => applyTemplate(drawTiger));
document.getElementById('tpl-spongebob').addEventListener('click', () => applyTemplate(drawSpongebob));

// ─── Animation Loop ───────────────────────────────────────────────────────────
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const time = clock.getElapsedTime();
  if (state.turnips.length > 0) updateFlicker(time);
  if (controls.enabled) controls.update();
  composer.render();
}

// ─── Resize ───────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  composer.setSize(w, h);
  bloomPass.resolution.set(Math.floor(w * 0.5), Math.floor(h * 0.5));
});

// ─── Start ────────────────────────────────────────────────────────────────────
setMode('rotate');
animate();
  </script>
</body>
</html>
